import { NextRequest, NextResponse } from "next/server";
import db, { initDb } from "../../../../../../db";

export const runtime = "nodejs";

export async function POST(
  req: NextRequest,
  context: { params: Promise<{ id: string; ep: string }> }
) {
  await initDb();

  const { id: novelId, ep } = await context.params;
  const { language } = await req.json();

  if (!language) {
    return NextResponse.json(
      { error: "LANGUAGE_REQUIRED" },
      { status: 400 }
    );
  }

  // 1️⃣ 원문 조회
  const episodeRes = await db.query(
    `
    SELECT content
    FROM episodes
    WHERE novel_id = $1 AND ep = $2
    `,
    [novelId, Number(ep)]
  );

  if (episodeRes.rowCount === 0) {
    return NextResponse.json(
      { error: "EPISODE_NOT_FOUND" },
      { status: 404 }
    );
  }

  const sourceText = episodeRes.rows[0].content;

  // 2️⃣ 번역 파이프라인 호출
  const pipelineBase = process.env.PIPELINE_BASE_URL;
  const pipelinePin = process.env.PIPELINE_PIN;

  if (!pipelineBase || !pipelinePin) {
    return NextResponse.json(
      { error: "PIPELINE_ENV_NOT_SET" },
      { status: 500 }
    );
  }

  const pipelineRes = await fetch(`${pipelineBase}/translate`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Access-Pin": pipelinePin,
    },
    body: JSON.stringify({
      novel_title: novelId,
      text: sourceText,
      target_language: language,
    }),
  });

  if (!pipelineRes.ok) {
    return NextResponse.json(
      { error: "PIPELINE_FAILED" },
      { status: 500 }
    );
  }

  const { translated_text } = await pipelineRes.json();

  // 3️⃣ 번역 결과 저장 (UPSERT)
  await db.query(
    `
    INSERT INTO episode_translations (novel_id, ep, language, translated_text)
    VALUES ($1, $2, $3, $4)
    ON CONFLICT (novel_id, ep, language)
    DO UPDATE SET translated_text = EXCLUDED.translated_text
    `,
    [novelId, Number(ep), language, translated_text]
  );

  return NextResponse.json({ status: "ok" });
}
